\documentclass[12pt,a4paper]{article}

% Margins.
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\headheight}{12pt}
\setlength{\headsep}{42pt}
\setlength{\topmargin}{-54pt}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{10in}

\usepackage{amsmath}
\usepackage{float}
\usepackage{graphicx}
\usepackage[hyphens]{url}
\usepackage{hyperref}	% Clickable links to figures, references and urls.

% Drawing.
\usepackage{pgf}
\usepackage{tikz}

% Listings for formatting code.
\usepackage{listings}
% General options.
\lstset{breaklines=true, basicstyle=\footnotesize\ttfamily, tabsize=4, numbers=left, stepnumber=1, frame=single, showstringspaces=false}
% C++ specific high-lighting. Comments are 50/50 shades of green/black and strings coloured with 60/40 red/black mixture.
\lstset{language=[ISO]C++, commentstyle=\color{green!50!black}, keywordstyle=\color{blue}, stringstyle=\color{red!60!black}}

%opening
\title{\vspace{-2cm}Programming for Engineers II\\Class 07\\Relationship Between Classes\\Composition and Aggregation}
\author{Attique Dawood}

\begin{document}
\maketitle
\section{Announcements}
\begin{itemize}
\item Assignment based quiz will be on Friday. All quizzes are by default scheduled for Friday.
\item ABQ will be based on complex number and matrix codes. In addition everything covered in the class is also included.
\end{itemize}
\section{Revision}
\begin{itemize}
\item Relationship between classes.
\item Inheritance: Base class and derived class.
\item Derived class inherits all attributes and functions of base class. A student has all the attributes of a person in addition to CGPA and roll number.
\item UML class diagram.
\item Class is represented by name, data and attributes grouped in a box.
\item Private and public methods are preceded by `-' or `+' sign.
\item Inheritance is represented by an empty or hollow arrow--head from derived class to base class.
\end{itemize}
\section{Relationship Between Classes}
\subsection{``is a'' Relationship}
\begin{itemize}
\item Car is the base class.
\item Honda \textbf{is a} car.
\item Toyota \textbf{is a} car.
\end{itemize}
\begin{itemize}
\item Mobile phone is the base class.
\item Apple iPhone \textbf{is a} mobile phone.
\item Samsung Galaxy \textbf{is a} mobile phone.
\end{itemize}
\begin{itemize}
\item Person is the base class.
\item Teacher \textbf{is a} person.
\item Student \textbf{is a} person.
\end{itemize}
Derived classes have all the features (attributes and functionality) of base class in addition to some features specific to it. A person will have a name and age. A student in addition to name and age will also have a CGPA.
\subsection{``has a'' Relationship or Aggregation}
A class can be a member of another classes. Weak link, empty diamond.
\begin{itemize}
\item That teacher \textbf{has a}n Apple iPhone.
\item That student \textbf{has a} Samsung Galaxy.
\item A person has address. If a person dies, address is unaffected.
\end{itemize}
\subsection{``part of''/``composed of'' Relationship or Composition}
A class can be a part of another classes. Strong link, filled diamond. If the container class is destroyed so is the contained class.
\begin{itemize}
\item Compressor is a \textbf{part of} AC. If AC is scrapped, compressor goes with it.
\item Engine is a \textbf{part of} car. 
\item Tyre is also a \textbf{part of} car. If a car is destroyed, this implies everything contained within is scrap metal and useless.
\item Organs of a person cannot sustain if the person dies.
\end{itemize}
\subsection{``using a'' and ``knows a'' Relationship}
\begin{itemize}
\item A person driving a car is an association between two objects. Person is `using' a car.
\item Student X and talking to student Y because they `know' each other and exchange views.
\item A remote control can interact or talk to AC.
\end{itemize}
\section{\texttt{const} Variables}
\begin{itemize}
\item A variable declared with \verb|const| directive.
\item Value of a constant variable cannot change throughout the execution of a program.
\item Can only be initialised at declaration.
\end{itemize}
\section{\texttt{inline} Functions}
\begin{itemize}
\item Functions can be defined as \verb|inline|.
\item This is mainly a compiler level optimisation.
\end{itemize}
\section{Constructor}
\begin{itemize}
\item A constructor is a very special function in a class.
\item Name of constructor is the name of class.
\item It doesn't have a return type. Mentioning a return type is an error.
\item A constructor is called exactly once throughout the life of an object; only at its creation. Actually, just before the creation.
\item The purpose of a constructor is to initialise data members or variables etc.
\item Even if a constructor isn't defined, compiler will create a default constructor which doesn't do anything.
\item A constructor, default or otherwise, will always be called upon object creation.
\item Constructor can take arguments.
\item Different constructors can be defined. They can be differentiated through their argument list.
\end{itemize}
\begin{lstlisting}[caption={Object--oriented approach to add complex numbers}]
#include <iostream>
using std::cin;
using std::cout;
using std::endl;

class complex
{
	private:
	float real;
	float img;
	
	public:
	complex(); // Default constructor.
	complex(float,float); // User-defined constructor.
	
	void Input();
	void Display();
	complex Add(complex);
	complex DivideBy(complex);
};

// Class functions can be defined inside or outside the class.
// Here, functions are defined outside the class.
// Notice the `::' operator.
complex::complex()
{
	real = 0.f;
	img = 0.f;
}
complex::complex(float pr, float pi)
{
	real = pr;
	img = pi;
}
void complex::Input()
{
	cout << "Enter complex number: ";
	cin >> real >> img;
}
void complex::Display()
{
	if (img < 0.f)
		cout << real << " - j" << -1.f*img << endl;
	else
		cout << real << " + j" << img << endl;
}
complex complex::Add(complex c)
{
	complex result;
	result.real = real + c.real;
	result.img = img + c.img;
	
	return result;
}

int main()
{
	complex complex1;	// Default constructor called. 0+j0.
	complex complex2(3.2, 2.5); // Complex initialised to 3.2+j2.5
	complex complex3;	// Default constructor.
	
	// Addition.
	complex3 = complex1.Add(complex2);
	
	// Result.
	cout << "Result is: ";
	complex3.Display();
	
	return 0;
}
\end{lstlisting}
\nocite{*}
\bibliographystyle{plain}
\bibliography{OOPref}
\end{document}
